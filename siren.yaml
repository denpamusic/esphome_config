substitutions:
  name: "melon"
  friendly_name: "Melon"

  # [Project]
  platform: "d1_mini"
  manufacturer: "lolin"
  project_name: "siren"
  version: "1.3.1"

  # [Buzzer]
  min_volume: "0.0"
  max_volume: "1.0"
  short_beep_length: "100"
  long_beep_length: "500"
  startup_beep_volume: "0.3"
  startup_beep_length: "100"
  buzzer_freq: 2700Hz

  # [RTTTL]
  rtttl_confirm: "0"
  rtttl_reject: "1"
  rtttl_warning: "2"
  rtttl_success: "3"

  # [GPIOs]
  status_led_pin: 2
  rgb_led_pin: D2
  buzzer_pin: D8

  # [Error]
  error_siren: "Can't play tone while sounding the siren."
  error_unknown_tone: "Unknown tone %s"

esphome:
  name: ${name}
  friendly_name: $friendly_name
  min_version: 2024.6.0
  name_add_mac_suffix: False
  project:
    name: "${manufacturer}.${project_name}"
    version: ${version}
  on_boot:
    then:
      - script.execute:
          id: turn_on_buzzer
          duration_ms: ${startup_beep_length}
          volume: ${startup_beep_volume}
          priority: False
          red: 0.0
          green: 1.0
          blue: 0.0

esp8266:
  board: ${platform}

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "3AJQRI1MIKl9K5vnMFjGlV//S/jN1dkCARvqQOqbnz4="
  services:
    - service: play_tone
      variables:
        name: string
        priority: bool
        volume: int
      then:
        - script.execute:
            id: play_tone
            name: !lambda "return name;"
            priority: !lambda "return priority;"
            volume: !lambda "return (float)volume / 100.0f;"

    - service: beep
      variables:
        duration_ms: int
        priority: bool
        volume: int
      then:
        - script.execute:
            id: play_beep
            duration_ms: !lambda "return duration_ms;"
            priority: !lambda "return priority;"
            volume: !lambda "return (float)volume / 100.0f;"

    - service: siren
      variables:
        priority: bool
        ramp_up: bool
        volume: int
      then:
        - script.execute:
            id: play_siren
            priority: !lambda "return priority;"
            ramp_up: !lambda "return ramp_up;"
            volume: !lambda "return (float)volume / 100.0f;"

ota:
  - platform: esphome
    password: !secret melon_ota_password

wifi:
  ssid: !secret wifi_iot_ssid
  password: !secret wifi_iot_password
  min_auth_mode: WPA2
  ap:
    ssid: "${friendly_name} Fallback Hotspot"
    password: !secret melon_fallback_password

captive_portal:

globals:
  - id: tones
    type: std::vector<std::string>
    initial_value: '{
      "Confirm:d=8,o=6,b=90:64c,64e,64g",
      "Reject:d=8,o=4,b=180:e.,e",
      "Warning:d=4,o=6,b=50:16e6,16c6,16e6,16p,16e6,16p,16e6,16c6,16e6,16c6,16e6,16p,16e6,16p,16e6,16c6,16e6,16c6,16e6,16p,16e6,16p,16e6,16c6,16e6,16c6,16e6,16p,16e6,16p,16e6,16c6,16e6,16c6,16e6,16p,16e6,16p,16e6,16c6,16e6,16c6,16e6,16p,16e6,16p,16e6,16c6,16e6,16c6,16e6",
      "Success:d=8,o=6,b=180:g,p,g",
    }'
    restore_value: False

output:
  - platform: esp8266_pwm
    pin: ${buzzer_pin}
    id: buzzer
    frequency: ${buzzer_freq}
    min_power: ${min_volume}
    max_power: ${max_volume}

script:
  - id: turn_on_rtttl
    parameters:
      tone: int
      priority: bool
      volume: float
      red: float
      green: float
      blue: float
    then:
      - light.turn_on:
          id: rgb_light
          brightness: 100%
          red: !lambda "return red;"
          green: !lambda "return green;"
          blue: !lambda "return blue;"
          transition_length: 0sec
      - if:
          condition:
            or:
              - switch.is_off: mute_mode
              - lambda: "return priority;"
          then:
            - lambda: "id(buzzer).set_max_power(volume);"
            - rtttl.play: !lambda "return id(tones)[tone].c_str();"
            - wait_until:
                not:
                  - rtttl.is_playing
          else:
            - delay: 250ms
      - light.turn_off:
          id: rgb_light
          transition_length: 0sec

  - id: turn_on_buzzer
    parameters:
      duration_ms: int
      priority: bool
      volume: float
      red: float
      green: float
      blue: float
    then:
      - light.turn_on:
          id: rgb_light
          brightness: 100%
          red: !lambda "return red;"
          green: !lambda "return green;"
          blue: !lambda "return blue;"
          flash_length: !lambda "return duration_ms;"
      - if:
          condition:
            or:
              - switch.is_off: mute_mode
              - lambda: "return priority;"
          then:
            - lambda: "id(buzzer).set_max_power(volume);"
            - output.turn_on: buzzer
            - output.esp8266_pwm.set_frequency:
                id: buzzer
                frequency: ${buzzer_freq}
            - output.set_level:
                id: buzzer
                level: 30%
            - delay: !lambda "return duration_ms;"
            - output.turn_off: buzzer

  - id: play_beep
    parameters:
      duration_ms: int
      priority: bool
      volume: float
    then:
      - if:
          condition:
              switch.is_on: siren
          then:
              - logger.log: ${error_siren}
          else:
            - script.execute:
                id: turn_on_buzzer
                duration_ms: !lambda "return duration_ms;"
                priority: !lambda "return priority;"
                volume: !lambda "return volume;"
                red: 0.0
                green: 0.0
                blue: 1.0
            - script.wait: turn_on_buzzer

  - id: play_tone
    parameters:
      name: string
      priority: bool
      volume: float
    then:
      - if:
          condition:
            switch.is_on: siren
          then:
            - logger.log: ${error_siren}
            - script.stop: play_tone

      - if:
          condition:
            lambda: 'return name == "confirm";'
          then:
            - script.execute:
                id: turn_on_rtttl
                tone: ${rtttl_confirm}
                priority: !lambda "return priority;"
                volume: !lambda "return volume;"
                red: 0.0
                green: 0.0
                blue: 1.0
            - script.stop: play_tone

      - if:
          condition:
            lambda: 'return name == "reject";'
          then:
            - script.execute:
                id: turn_on_rtttl
                tone: ${rtttl_reject}
                priority: !lambda "return priority;"
                volume: !lambda "return volume;"
                red: 1.0
                green: 0.0
                blue: 0.0
            - script.stop: play_tone

      - if:
          condition:
            lambda: 'return name == "warning";'
          then:
            - script.execute:
                id: turn_on_rtttl
                tone: ${rtttl_warning}
                priority: !lambda "return priority;"
                volume: !lambda "return volume;"
                red: 1.0
                green: 0.8
                blue: 0.0
            - script.stop: play_tone

      - if:
          condition:
            lambda: 'return name == "success";'
          then:
            - script.execute:
                id: turn_on_rtttl
                tone: ${rtttl_success}
                priority: !lambda "return priority;"
                volume: !lambda "return volume;"
                red: 0.0
                green: 1.0
                blue: 0.0
            - script.stop: play_tone

      - logger.log:
          format: ${error_unknown_tone}
          args: [ "name.c_str()" ]

  - id: siren_cycle
    parameters:
      priority: bool
      volume: float
    then:
      - repeat:
          count: 3
          then:
            - script.execute:
                id: turn_on_buzzer
                duration_ms: 500
                priority: !lambda "return priority;"
                volume: !lambda "return volume;"
                red: 1.0
                green: 0.0
                blue: 0.0
            - script.wait: turn_on_buzzer
            - delay: 250ms
      - delay: 750ms

  - id: play_siren
    parameters:
      priority: bool
      ramp_up: bool
      volume: float
    then:
      - if:
          condition:
            lambda: "return ramp_up;"
          then:
            - script.execute:
                id: siren_cycle
                volume: !lambda "return volume * 0.1f;"
                priority: !lambda "return priority;"
            - script.wait: siren_cycle

            - script.execute:
                id: siren_cycle
                volume: !lambda "return volume * 0.3f;"
                priority: !lambda "return priority;"
            - script.wait: siren_cycle

      - while:
          condition:
            - lambda: "return true;"
          then:
            - script.execute:
                id: siren_cycle
                volume: !lambda "return volume;"
                priority: !lambda "return priority;"
            - script.wait: siren_cycle

rtttl:
  id: rtttl_player
  output: buzzer

switch:
  - platform: template
    id: siren
    name: "Siren"
    restore_mode: ALWAYS_OFF
    optimistic: True
    turn_on_action:
      then:
        - script.execute:
            id: play_siren
            priority: True
            ramp_up: True
            volume: ${max_volume}
    turn_off_action:
      then:
        - script.stop: play_siren

  - platform: template
    id: mute_mode
    name: "Mute mode"
    icon: "mdi:volume-off"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: True
    entity_category: "config"

number:
  - platform: template
    id: volume
    name: "Volume"
    icon: "mdi:volume-medium"
    min_value: 5
    max_value: 100
    step: 1
    unit_of_measurement: "%"
    optimistic: True
    restore_value: True
    initial_value: 100
    entity_category: "config"

button:
  - platform: template
    name: "Short beep"
    on_press:
      then:
        - script.execute:
            id: play_beep
            priority: True
            duration_ms: ${short_beep_length}
            volume: ${max_volume}

  - platform: template
    name: "Long beep"
    on_press:
      then:
        - script.execute:
            id: play_beep
            priority: True
            duration_ms: ${long_beep_length}
            volume: ${max_volume}

light:
  - platform: status_led
    id: blue_light
    pin:
      number: ${status_led_pin}
      inverted: true

  - platform: neopixelbus
    id: rgb_light
    type: RGB
    variant: WS2812X
    pin: ${rgb_led_pin}
    num_leds: 1

binary_sensor:
  - platform: status
    name: "Node status"

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP address"
    mac_address:
      name: "MAC address"

sensor:
  - platform: wifi_signal
    name: "WLAN RSSI"
    update_interval: 60s